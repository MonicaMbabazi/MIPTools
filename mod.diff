--- mip_mod_testing.py	(original)
+++ mip_mod_testing.py	(refactored)
@@ -10,7 +10,7 @@
 @author: oz
 """
 import json
-import cPickle as pickle
+import pickle as pickle
 import os
 import subprocess
 #from uniformity_functions_updated import *
@@ -19,7 +19,7 @@
 import mip_functions_testing as mip
 import copy
 import numpy as np
-print "mip module reloading"
+print("mip module reloading")
 import math
 import pandas as pd
 
@@ -251,7 +251,7 @@
                 # multiple changes will be split
                 # if it is not a deletion
                 elif "-" not in copy_base:
-                    for i in xrange(end - begin):
+                    for i in range(end - begin):
                         if diff_ori == "forward":
                             d = {"chrom": ref_chrom,
                              "begin": begin + i + 1,
@@ -353,7 +353,7 @@
                          "copy_base": copy_base,
                             "size_difference": 0}
                 elif "-" not in copy_base:
-                    for i in xrange(end - begin):
+                    for i in range(end - begin):
                         if diff_ori == "forward":
                             d = {"chrom": ref_chrom,
                              "begin": begin + i + 1,
@@ -422,7 +422,7 @@
                 if len(alleles) > 1:
                     alleles.pop(-1)
                     allele_counts.pop(-1)
-                    allele_counts = map(int, map(float, allele_counts))
+                    allele_counts = list(map(int, list(map(float, allele_counts))))
                     #major_allele_count = max(allele_counts)
                     reference_allele_count = allele_counts[0]
                     total_allele_count = sum(allele_counts)
@@ -436,7 +436,7 @@
                 if s[6] == "-":
                     snp_ori = "reverse"
                     ref_base = mip.reverse_complement(ref_base)
-                    observed = map(mip.reverse_complement, observed) 
+                    observed = list(map(mip.reverse_complement, observed)) 
                 d = {"copy_chrom": s[1],
                      "copy_begin": int(s[2]),
                      "copy_end": int(s[3]),
@@ -603,9 +603,9 @@
                         copy_base = snp["copy_base"]
                         copy_begin = snp["copy_begin"]
                         alleles = snp["alleles"]
-                        allele_counts = map(int, snp["info"]["AC"])
-                        a_total = max_alleles = max(map(int, snp["info"]["AN"]))
-                        for allele_index in xrange(len(alleles)):
+                        allele_counts = list(map(int, snp["info"]["AC"]))
+                        a_total = max_alleles = max(list(map(int, snp["info"]["AN"])))
+                        for allele_index in range(len(alleles)):
                             split_snp = {"copy_chrom": copy_chrom,
                                         "chrom": chrom}
                             a = alleles[allele_index]
@@ -718,7 +718,7 @@
             an = r["AN"]
             ac = r["AC"]
             res = []
-            for i in xrange(r_begin, r_end + 1):
+            for i in range(r_begin, r_end + 1):
                 res.append([r_chrom, i, ac, an])
             return pd.DataFrame(res, columns = ["chrom",
                                                "position",
@@ -750,7 +750,7 @@
         diff_df = self.all_variants.loc[self.all_variants["variant_type"] != "snps"]
         split_diff_list = [
             pd.DataFrame([[diff_df.loc[diff_index]["chrom"],
-                           i] for i in xrange(
+                           i] for i in range(
                 diff_df.loc[diff_index]["begin"],
                 diff_df.loc[diff_index]["end"] + 1)],
                      columns = ["chrom", "position"])
@@ -887,7 +887,7 @@
                         if (e[0] <= must[c][m]["begin"]
                             <= must[c][m]["end"] <= e[1]):
                             uncaptured[c].pop(m)
-            for c in uncaptured.keys():
+            for c in list(uncaptured.keys()):
                 if len(uncaptured[c]) == 0:
                     uncaptured.pop(c)
             # print any uncaptured snp
@@ -981,10 +981,10 @@
                         if field == "settings_for":
                             settings_dict[key] = {}
                             field_names[key] = {}
-                            for i in xrange(len(values)):
+                            for i in range(len(values)):
                                 field_names[key][i] = values[i]
                         else:
-                            for i in xrange(len(values)):
+                            for i in range(len(values)):
                                 fname = field_names[key][i]
                                 try:
                                     settings_dict[key][fname][field] = values[i]
@@ -994,8 +994,8 @@
         must_list = np.transpose(must_list).tolist()
         try:
             f_names = must_list[0]
-            for i in xrange(1, len(must_list)):
-                m_dict = dict(zip(f_names, must_list[i]))
+            for i in range(1, len(must_list)):
+                m_dict = dict(list(zip(f_names, must_list[i])))
                 must_dict[m_dict["name"]] = m_dict
         except IndexError:
             pass
@@ -1155,8 +1155,8 @@
         else:
             s = seg.make_subregions()
             if len(s) == 0:
-                print ("Nothing interesting in segment %s of paralog %s"
-                       %(seg.segment_name, seg.paralog.paralog_name))
+                print(("Nothing interesting in segment %s of paralog %s"
+                       %(seg.segment_name, seg.paralog.paralog_name)))
                 return "failed"
             s.sort(key=itemgetter(0))
             counter = 0
@@ -1192,11 +1192,11 @@
             
                 with open(self.cwd + self.paralog_name, "w") as savefile:
                     pickle.dump(self, savefile)
-            except Exception, e:
+            except Exception as e:
                 sub.failed = True
-                print sub.fullname, " failed due to error ", str(e)
+                print(sub.fullname, " failed due to error ", str(e))
         else:
-            print sub.fullname, " design has failed before and will not be repeated."
+            print(sub.fullname, " design has failed before and will not be repeated.")
             return
         
     
@@ -1336,9 +1336,9 @@
                         if t in caps:
                             line = "Target " + self.must[c][t]["name"] + " is captured."
                             #print line
-                            print ("Target %s of %s is captured."
+                            print(("Target %s of %s is captured."
                                   %(self.must[c][t]["name"],
-                                   self.paralog_name))
+                                   self.paralog_name)))
                             outfile_list.append("#" + line)
                             # add the name of captured target to list
                             ms.append(self.must[c][t]["name"])
@@ -1381,16 +1381,16 @@
                     line = "Target" + " " + self.must[c][t]["name"] + " is NOT captured."
                     outfile_list.append("#" + line)
                     #print line
-                    print ("Target %s of %s is NOT captured."
+                    print(("Target %s of %s is NOT captured."
                           %(self.must[c][t]["name"], 
-                           self.paralog_name))
+                           self.paralog_name)))
         if not target_remaining:
             line = "All targets have been captured."
             self.must_captured = True
             outfile_list.append("#" + line + "\n")
             #print line
-            print ("All targets have been captured for %s."
-                  % self.paralog_name)
+            print(("All targets have been captured for %s."
+                  % self.paralog_name))
         else:
             self.must_captured = False
         if self.chained_mips:
@@ -1398,7 +1398,7 @@
         else:
             line = "Mips not chained"
         outfile_list.append("#" + line + "\n")
-        print line, "for", self.paralog_name
+        print(line, "for", self.paralog_name)
         outfile.write("\n".join(outfile_list))
         outfile.close()
         self.locus_info = locus_info
@@ -1673,9 +1673,9 @@
                         if t in caps:
                             line = "Target " + self.must[c][t]["name"] + " is captured."
                             #print line
-                            print ("Target %s of %s is captured."
+                            print(("Target %s of %s is captured."
                                   %(self.must[c][t]["name"],
-                                   self.paralog_name))
+                                   self.paralog_name)))
                             outfile_list.append("#" + line)
                             # add the name of captured target to list
                             ms.append(self.must[c][t]["name"])
@@ -1716,15 +1716,15 @@
                     line = "Target" + " " + self.must[c][t]["name"] + " is NOT captured."
                     outfile_list.append("#" + line)
                     #print line
-                    print ("Target %s of %s is NOT captured."
+                    print(("Target %s of %s is NOT captured."
                           %(self.must[c][t]["name"],
-                           self.paralog_name))
+                           self.paralog_name)))
         if not target_remaining:
             line = "All targets have been captured."
             self.must_selected = True
             outfile_list.append("#" + line + "\n")
             #print line
-            print "All targets have been captured for %s" %self.paralog_name
+            print("All targets have been captured for %s" %self.paralog_name)
         else:
             self.must_selected = False
             
@@ -2177,13 +2177,13 @@
         self.scoring = {"snp_scores":{}, "diff_scores":{} }
         snps = self.capture["target_snp_functions"].split(",")
         if snps != ["none"]:
-            snp_scores = map(int,self.capture["score_snp_functions"].split(","))
-            for i in xrange(len(snps)):
+            snp_scores = list(map(int,self.capture["score_snp_functions"].split(",")))
+            for i in range(len(snps)):
                 self.scoring["snp_scores"][snps[i]] = snp_scores[i]
         diffs = self.capture["target_diffs"].split(",")
         if diffs != ["none"]:
-            diff_scores = map(int,self.capture["score_target_diffs"].split(","))
-            for i in xrange(len(diffs)):
+            diff_scores = list(map(int,self.capture["score_target_diffs"].split(",")))
+            for i in range(len(diffs)):
                 self.scoring["diff_scores"][diffs[i]] = diff_scores[i]
         self.scoring["mask_penalty"] = int(self.capture["mask_penalty"])
         self.scoring["unique_copy_bonus"] = int(self.capture["unique_copy_bonus"])
@@ -2491,13 +2491,13 @@
         return
 
     def score_mips(self):
-        for m in self.mips["hairpin"].keys():
+        for m in list(self.mips["hairpin"].keys()):
             try:
                 self.mips["hairpin"][m].add_capture_info()
             except:
                 self.mips["hairpin"].pop(m)
         
-        for m in self.mips["hairpin"].keys():
+        for m in list(self.mips["hairpin"].keys()):
             try:
                 self.mips["hairpin"][m].score_mips()
             except:
@@ -2524,8 +2524,8 @@
         self.mips["scored_filtered"]= {"dictionary": temp_scored,
                                       "filename": self.fullname + "_scored_filtered"}
         
-        for m in self.mips["scored_filtered"]["dictionary"]["pair_information"].keys():
-            if m not in temp_dic.keys():
+        for m in list(self.mips["scored_filtered"]["dictionary"]["pair_information"].keys()):
+            if m not in list(temp_dic.keys()):
                 self.mips["scored_filtered"]["dictionary"]["pair_information"].pop(m)
         with open(self.primer3_output_DIR + self.mips["scored_filtered"]["filename"], "w") as infile:
             json.dump(self.mips["scored_filtered"]["dictionary"], infile, indent=1)
@@ -2801,10 +2801,10 @@
                 self.mips["best_mipset"]["dictionary"]["caps"] = best_caps
                 self.mips["best_mipset"]["dictionary"]["score"] = best_score
                 # if there are no compatible mipsets, then find the best mip
-            elif self.single and (len(mip_dic["pair_information"].keys()) > 0):
+            elif self.single and (len(list(mip_dic["pair_information"].keys())) > 0):
                 #best_score = 0
                 #best_mip = ""
-                for mip_key in mip_dic["pair_information"].keys():
+                for mip_key in list(mip_dic["pair_information"].keys()):
                     mip_obj = self.mips["hairpin"][mip_key]
                     uniq = mip_obj.capture_info["unique_captures"]
                     if  mip_obj.tech_score != 0 and  mip_obj.func_score != 0:
@@ -2825,7 +2825,7 @@
                 self.mips["best_mipset"]["dictionary"]["score"] = best_score
                 best_set_chained = False
             else:
-                print "No mips available for target region %s" %self.fullname
+                print("No mips available for target region %s" %self.fullname)
         # if compatibility test should be skipped
         else:
             with open(self.primer3_output_DIR + self.mips["scored_filtered"]["filename"], "r") as infile:
@@ -2875,7 +2875,7 @@
             selection_skip = False
         if (self.capture["capture_type"] == "targets") and not selection_skip:
             best_mipset = self.mips["best_mipset"]["dictionary"]["mips"]
-            for mip_key in best_mipset.keys():
+            for mip_key in list(best_mipset.keys()):
                 if len(best_mipset[mip_key].capture_info["captured_targets"]) == 0:
                     best_mipset.pop(mip_key)
         return
